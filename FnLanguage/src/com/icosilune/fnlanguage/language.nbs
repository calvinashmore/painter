# To change this template, choose Tools | Templates
# and open the template in the editor.

#<DEFAULT>:


TOKEN:comment: ( "//" [^"\n" "\r"]* ["\n" "\r"]+ )
TOKEN:comment: ( "/*" - "*/")

TOKEN:string: (
    "\"" ([^ "\\" "\""] |
          ("\\" (. |
                 (["0"-"7"]) |
                 (["0"-"7"] ["0"-"7"]) | 
                 (["0"-"7"] ["0"-"7"] ["0"-"7"])
                 ("^" ["@" "A"-"Z" "["-"_"])
                )
          )
         )* 
    "\""
)

# definition of tokens
#TOKEN:keyword:( "package" | "while" | "if" | "else" | "group" | "type" | "import")
TOKEN:java_keyword:( "abstract" | "continue" | "for" | "new" | "switch" |
                     "assert" | "default" | "goto" | "package" | "synchronized" |
                     "boolean" | "do" | "if" | "private" | "this" |
                     "break" | "double" | "implements" | "protected" | "throw" |
                     "byte" | "else" | "import" | "public" | "throws" |
                     "case" | "enum" | "instanceof" | "return" | "transient" |
                     "catch" | "extends" | "int" | "short" | "try" |
                     "char" | "final" | "interface" | "static" | "void" |
                     "class" | "finally" | "long" | "strictfp" | "volatile" |
                     "const" | "float" | "native" | "super" | "while" )

TOKEN:fn_keyword:( "fn" | "group" | "type" | "in" |
                   "fout" | "eval" | "exec" | "init" |
                   "parameter" | "setup" | "meta" |
                   "slin" | "exin" | "cvar")

TOKEN:operator:( "{" | "}" | "(" | ")" |
                 "+" | "-" | "/" | "%" | "*" |
                 "++" | "--" | "~" | "^" | "|" | "&" | "!" |
                 "&&" | "||" | "<<" | ">>" | ">>>" | "<" | ">" |
                 "<=" | ">=" | "instanceof" | "?" | ":" |
                 "=" | "==" | "!=" | "=+" | "=*" | "=/" | "=%" |
                 "&=" | "^=" | "|=" | "<<=" | ">>=" | ">>>=" |
                 ";" | "." | "@")

TOKEN:fn_type:("Expression" | "Statement" | "Command" | "Accessor")

TOKEN:identifier:( ["a"-"z"] ["a"-"z" "0"-"9"]* )
TOKEN:whitespace:( [" " "\t" "\n" "\r"]+ )

# parser should ignore whitespaces
SKIP:whitespace
SKIP:comment

# definition of grammar
S =  PackageDeclaration FnGroupStatement FnTypeStatement (ImportDeclaration)* (FnDefinition)*;
#S = (Statement)*;

FnGroupStatement = "group" Name ";";
FnTypeStatement = "type" ("Expression" | "Statement" | "Command" | "Accessor") ";";

FnDefinition = "fn" <identifier> "{" (FnField)* "}";
FnField = FnBlock | FnTypeAndName | FnType | FnMeta | FnLocal;
FnBlock = ("eval" | "exec" | "setup" | "init") Block;
FnTypeAndName = ("in" | "exin" | "parameter" | "cvar") Type <identifier> ";";
FnType = FnOut | FnInterface | FnSLIn;
FnOut = "out" Type ";";
FnInterface = "interface" Name ";";
FnMeta = "meta" <identifier> "=" Expression ";";
FnLocal = Modifiers (ClassOrInterfaceDeclaration | FieldDeclaration | MethodDeclaration);

# JAVA Language grammar
CompilationUnit = [ PackageDeclaration ] ( ImportDeclaration )* ( TypeDeclaration )*;

PackageDeclaration = "package" Name ";";
ImportDeclaration = "import" Name ["." "*"] ";";

Modifiers = (
           "public" | "static" | "protected" | "private"
          | "final" | "abstract" | "synchronized" | "native"
          | "transient" | "volatile" | "strictfp" | Annotation() )*;

TypeDeclaration = ";" | ( Modifiers (
            ClassOrInterfaceDeclaration
          | EnumDeclaration
          | AnnotationTypeDeclaration ));

ClassOrInterfaceDeclaration = ( "class" | "interface" ) <identifier> 
          [ TypeParameters ]
          [ ExtendsList ]
          [ ImplementsList ]
          ClassOrInterfaceBody;

ExtendsList = "extends" ClassOrInterfaceType()
          ( "," ClassOrInterfaceType())*;
ImplementsList = "implements" ClassOrInterfaceType()
          ( "," ClassOrInterfaceType())*;

EnumDeclaration = "enum" <identifier> [ImplementsList] EnumBody;
EnumBody = "{" EnumConstant ( "," EnumConstant )* [ ";" ( ClassOrInterfaceBodyDeclaration )* ] "}";
EnumConstant = <identifier> [ Arguments ] [ ClassOrInterfaceBody ];

TypeParameters = "<" TypeParameter ( "," TypeParameter )* ">";
TypeParameter = <identifier> [ TypeBound ];
TypeBound = "extends" ClassOrInterfaceType ( "&" ClassOrInterfaceType )*;

ClassOrInterfaceBody = "{" ( ClassOrInterfaceBodyDeclaration )* "}";

ClassOrInterfaceBodyDeclaration = Initializer | (Modifers (
      ClassOrInterfaceDeclaration
    | EnumDeclaration
    | ConstructorDeclaration
    | FieldDeclaration
    | MethodDeclaration
    ));

FieldDeclaration = Type VariableDeclarator ( "," VariableDeclarator )* ";";
VariableDeclarator = VariableDeclaratorId [ "=" VariableInitializer ];
VariableDeclaratorId = <identifier> ( "[" "]" )*;
VariableInitializer = ArrayInitializer | Expression;
ArrayInitializer = "{" [ VariableInitializer ( "," VariableInitializer )* ] [ "," ] "}";

MethodDeclaration = [ TypeParameters ] ResultType MethodDeclarator [ "throws" NameList ] ( Block | ";" );
MethodDeclarator = <identifier> FormalParameters ( "[" "]" )*;
FormalParameters = "(" [ FormalParameter ( "," FormalParameter )* ] ")";
FormalParameter = [ "final" ] Type [ "..." ] VariableDeclaratorId;

ConstructorDeclaration = [ TypeParameters ] <identifier> FormalParameters [ "throws" NameList ]
          "{" [ ExplicitConstructorInvocation ]
           ( BlockStatement )* "}";
ExplicitConstructorInvocation = ("this" Arguments() ";" ) | ("super" Arguments() ";") ;

Initializer = [ "static" ] Block;

Type = ReferenceType | PrimitiveType;
ReferenceType = (PrimitiveType ( "[" "]" )+ )
              | (ClassOrInterfaceType ( "[" "]" )* );
ClassOrInterfaceType = <identifier> [ TypeArguments() ] ( "." <identifier> [ TypeArguments() ] )*;
TypeArguments = "<" TypeArgument ( "," TypeArgument )* ">";
TypeArgument = ReferenceType | "?" [ WildcardBounds ];
WildcardBounds = ( "extends" | "super" ) ReferenceType;
PrimitiveType =  "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double";
ResultType = "void" | Type;

Name = <identifier> ("." <identifier>)*;
NameList = Name ( "," Name )*;

Expression = ConditionalExpression [ AssignmentOperator Expression ];
AssignmentOperator = "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=";
ConditionalExpression = ConditionalOrExpression [ "?" Expression ":" Expression ];
ConditionalOrExpression = ConditionalAndExpression ( "||" ConditionalAndExpression )*;
ConditionalAndExpression = InclusiveOrExpression ( "&&" InclusiveOrExpression )*;
InclusiveOrExpression = ExclusiveOrExpression ("|" ExclusiveOrExpression )*;
ExclusiveOrExpression = AndExpression ( "^" AndExpression )*;
AndExpression = EqualityExpression ( "&" EqualityExpression )*;
EqualityExpression = InstanceOfExpression ( ( "==" | "!=" ) InstanceOfExpression )*;
InstanceOfExpression = RelationalExpression [ "instanceof" Type ];
RelationalExpression = ShiftExpression ( ( "<" | ">" | "<=" | ">=" ) ShiftExpression )*;
ShiftExpression = AdditiveExpression ( ( "<<" | RSIGNEDSHIFT | RUNSIGNEDSHIFT ) AdditiveExpression )*;
AdditiveExpression = MultiplicativeExpression ( ( "+" | "-" ) MultiplicativeExpression )*;
MultiplicativeExpression = UnaryExpression ( ( "*" | "/" | "%" ) UnaryExpression )*;
UnaryExpression = (( "+" | "-" ) UnaryExpression)
                | PreIncrementExpression
                | PreDecrementExpression
                | UnaryExpressionNotPlusMinus;
PreIncrementExpression = "++" PrimaryExpression;
PreDecrementExpression = "--" PrimaryExpression;
UnaryExpressionNotPlusMinus = (( "~" | "!" ) UnaryExpression)
                | CastExpression()
                | PostfixExpression();
#CastLookahead =  "(" PrimitiveType
#                | "(" Type "[" "]"
#                | "(" Type ")" ( "~" | "!" | "(" | <identifier> | "this" | "super" | "new" | Literal );

PostfixExpression = PrimaryExpression() [ "++" | "--" ];
CastExpression = "(" Type ")" UnaryExpression
               | "(" Type ")" UnaryExpressionNotPlusMinus;
PrimaryExpression = PrimaryPrefix ( PrimarySuffix )*;
MemberSelector = "." TypeArguments <identifier>;
PrimaryPrefix =  Literal
                | "this"
                | "super" "." <identifier>
                | "(" Expression ")"
                | AllocationExpression
                | ResultType "." "class"
                | Name;
PrimarySuffix = "." "this"
                | "." AllocationExpression
                | MemberSelector
                | "[" Expression "]"
                | "." <identifier>
                | Arguments;
Literal = <INTEGER_LITERAL>
        | <FLOATING_POINT_LITERAL>
        | <CHARACTER_LITERAL>
        | <STRING_LITERAL>
        | BooleanLiteral
        | NullLiteral;
BooleanLiteral = "true" | "false";
NullLiteral = "null";

Arguments = "(" [ ArgumentList ] ")";
ArgumentList = Expression ( "," Expression )*;
AllocationExpression = ("new" PrimitiveType ArrayDimsAndInits)
                | ("new" ClassOrInterfaceType() [ TypeArguments() ]
                    ( ArrayDimsAndInits()
                    | Arguments() [ ClassOrInterfaceBody(false) ] ));
ArrayDimsAndInits = ("[" Expression "]" )+ ( "[" "]" )*
                    | ( "[" "]" )+ ArrayInitializer;

Statement =  LabeledStatement
        | AssertStatement
        | Block
        | EmptyStatement
        | StatementExpression ";"
        | SwitchStatement
        | IfStatement
        | WhileStatement
        | DoStatement
        | ForStatement
        | BreakStatement
        | ContinueStatement
        | ReturnStatement
        | ThrowStatement
        | SynchronizedStatement
        | TryStatement;
AssertStatement = "assert" Expression [ ":" Expression ] ";";
LabeledStatement = <identifier> ":" Statement;
Block = "{" ( BlockStatement )* "}";
BlockStatement = LocalVariableDeclaration ";"
                | Statement
                | ClassOrInterfaceDeclaration;
LocalVariableDeclaration = [ "final" ] Type VariableDeclarator ( "," VariableDeclarator )*;
EmptyStatement = ";";
StatementExpression = PreIncrementExpression
                    | PreDecrementExpression
                    | PrimaryExpression [ "++" | "--" | AssignmentOperator Expression ];
SwitchStatement = "switch" "(" Expression ")" "{" ( SwitchLabel ( BlockStatement )* )* "}";
SwitchLabel = ("case" Expression() ":") | ("default" ":");
IfStatement = "if" "(" Expression ")" Statement ["else" Statement ];
WhileStatement = "while" "(" Expression ")" Statement;
DoStatement = "do" Statement "while" "(" Expression ")" ";";
ForStatement =   "for" "("
      ( Type() <identifier> ":" Expression | [ ForInit ] ";" [ Expression ] ";" [ ForUpdate ] )
      ")" Statement;
ForInit = LocalVariableDeclaration | StatementExpressionList;
StatementExpressionList = StatementExpression ( "," StatementExpression )*;
ForUpdate = StatementExpressionList;
BreakStatement = "break" [ <identifier> ] ";";
ContinueStatement = "continue" [ <identifier> ] ";";
ReturnStatement = "return" [ Expression ] ";";
ThrowStatement = "throw" Expression ";";
SynchronizedStatement = "synchronized" "(" Expression ")" Block;
TryStatement = "try" Block ( "catch" "(" FormalParameter ")" Block )* [ "finally" Block ];

RUNSIGNEDSHIFT = ">" ">" ">";
RSIGNEDSHIFT = ">" ">";

Annotation = NormalAnnotation | SingleMemberAnnotation | MarkerAnnotation;
NormalAnnotation = "@" Name "(" [ MemberValuePairs ] ")";
SingleMemberAnnotation = "@" Name "(" MemberValue ")";
MemberValuePairs = MemberValuePair ( "," MemberValuePair )*;
MemberValuePair = <identifier> "=" MemberValue;
MemberValue = Annotation | MemberValueArrayInitializer | ConditionalExpression;
MemberValueArrayInitializer = "{" MemberValue ( "," MemberValue )* [ "," ] "}";
AnnotationTypeDeclaration = "@" "interface" <identifier> AnnotationTypeBody();
AnnotationTypeBody = "{" ( AnnotationTypeMemberDeclaration )* "}";
AnnotationTypeMemberDeclaration = Modifiers()
         ( Type() <IDENTIFIER> "(" ")" [ DefaultValue() ] ";"
          | ClassOrInterfaceDeclaration(modifiers)
          | EnumDeclaration(modifiers)
          | AnnotationTypeDeclaration(modifiers)
          | FieldDeclaration(modifiers) )
         | ( ";" );
DefaultValue = "default" MemberValue;


# code folding
FOLD:Block

# navigator support
NAVIGATOR:WhileStatement: {
    display_name: "$ConditionalExpression$";
}

# brace completion
COMPLETE "{:}"
COMPLETE "(:)"
COMPLETE "[:]"

# brace matching
BRACE "{:}"
BRACE "(:)"
BRACE "[:]"

# indentation support
INDENT "{:}"
INDENT "(:)"
INDENT "[:]"
INDENT "\\s*(((if|while)\\s*\\(|else\\s*|else\\s+if\\s*\\(|for\\s*\\(.*\\))[^{;]*)"

# error highlighting
MARK:ERROR: {
    type:"Error";
    message:"Syntax error.";
}
MARK:error: {
    type:"Error";
    message:"Unexpected character.";
}

# code completion
COMPLETION:keyword, operator, identifier, whitespace: {
    text1:"while";
    text2:"if";
    text3:"else";
}



