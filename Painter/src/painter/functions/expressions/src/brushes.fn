package painter.functions.expressions;
group Brushes;
type Expression;

import utils.linear.*;
import painter.tools.brush.*;
import painter.tools.canvas.*;

description "expressions to generate brushes";

fn simpleBrush1 {
    fout Brush;
    in BrushPositionPolicy positionPolicy;
    in BrushSizePolicy sizePolicy;

    eval {
        return new SimpleBrush(positionPolicy, sizePolicy);
    }
}

fn simpleBrush2 {
    fout Brush;
    in BrushPositionPolicy positionPolicy;
    in BrushSizePolicy sizePolicy;

    parameter LDouble radiusMultiplier;
    init {
        radiusMultiplier = new LDouble(.2*Math.random()*.5);
    }

    eval {
        return new SimpleBrush(positionPolicy, sizePolicy, radiusMultiplier.val);
    }
}

fn simpleBrush3 {
    fout Brush;
    in LDouble radiusMultiplier;
    in BrushPositionPolicy positionPolicy;
    in BrushSizePolicy sizePolicy;

    eval {
        return new SimpleBrush(positionPolicy, sizePolicy, radiusMultiplier.val);
    }
}

fn hollowCircleBrush {
    fout Brush;
    in BrushPositionPolicy positionPolicy;
    in BrushSizePolicy sizePolicy;

    eval {
        return new HollowCircleBrush(positionPolicy, sizePolicy);
    }
}

fn penBrush {
    fout Brush;
    in BrushPositionPolicy positionPolicy;
    in BrushSizePolicy sizePolicy;

    eval {
        return new PenBrush(positionPolicy, sizePolicy);
    }
}

fn penBrush2 {
    fout Brush;
    in BrushPositionPolicy positionPolicy;
    in BrushSizePolicy sizePolicy;

    eval {
        return new DistortingPenBrush(positionPolicy, sizePolicy);
    }
}

/*fn sweepBrush1 {
    fout Brush;
    parameter int numberDots;
    parameter double dotSize;

    init {
        dotSize = .2+.8*Math.random();
        numberDots = (int)(3+5*Math.random());
    }

    eval {
        return new SweepBrush(numberDots, dotSize, new SimpleBrush());
    }
}*/

fn sweepBrush2 {
    fout Brush;
    parameter int numberDots;
    parameter double dotSize;

    in Brush brush;

    init {
        dotSize = .2+.8*Math.random();
        numberDots = (int)(3+5*Math.random());
    }

    eval {
        return new SweepBrush(numberDots, dotSize, brush);
    }
}

// ********************************
// Brush Policies
// ********************************

fn simplePositionPolicy {
    fout BrushPositionPolicy;
    parameter LDouble xAnchor;
    parameter LDouble yAnchor;
    parameter LDouble xDirection;
    parameter LDouble yDirection;

    init {
        if(Math.random() < .5) {
            // positive x direction
            xAnchor = new LDouble( Math.random() < .5 ? 0 : -1);
            xDirection = new LDouble( Math.random() < .5 ? 1 : .5);
        } else {
            // negative x direction
            xAnchor = new LDouble( Math.random() < .5 ? 0 : 1);
            xDirection = new LDouble( Math.random() < .5 ? -1 : -.5);
        }

        if(Math.random() < .5) {
            // positive y direction
            yAnchor = new LDouble( Math.random() < .5 ? 0 : -1);
            yDirection = new LDouble( Math.random() < .5 ? 1 : .5);
        } else {
            // negative y direction
            yAnchor = new LDouble( Math.random() < .5 ? 0 : 1);
            yDirection = new LDouble( Math.random() < .5 ? -1 : -.5);
        }
    }

    eval {return new SimpleBrushPositionPolicy(xAnchor.val, yAnchor.val, xDirection.val, yDirection.val);}
}

fn rotationPositionPolicy {
    fout BrushPositionPolicy;
    description "This is a policy that treats zero as centered, but rotates the canvas direction an arbitrary amount";
    parameter LDouble theta;
    interface BrushPositionPolicy;

    private double m00, m01, m10, m11;

    init {
        theta = new LDouble(Math.random() * 2 * Math.PI);
    }

    setup {
        m00 = Math.cos(theta.val);
        m01 = Math.sin(theta.val);
        m10 = -Math.sin(theta.val);
        m11 = Math.cos(theta.val);
    }

    public double getX(double x, double y, Canvas canvas) {
        return (.5 + x*m00 + y*m01) * canvas.getWidth();
    }

    public double getY(double x, double y, Canvas canvas) {
        return (.5 + x*m10 + y*m11) * canvas.getHeight();
    }

    eval {return this;}
}

fn skewPositionPolicy {
    fout BrushPositionPolicy;
    description "This is a policy that creates an arbitrary skew";
    parameter LDouble theta;
    interface BrushPositionPolicy;

    parameter LDouble m00;
    parameter LDouble m01;
    parameter LDouble m10;
    parameter LDouble m11;

    init {
        m00 = new LDouble(2*Math.random()-1);
        m01 = new LDouble(2*Math.random()-1);
        m10 = new LDouble(2*Math.random()-1);
        m11 = new LDouble(2*Math.random()-1);
    }

    public double getX(double x, double y, Canvas canvas) {
        return (.5 + x*m00.val + y*m01.val) * canvas.getWidth();
    }

    public double getY(double x, double y, Canvas canvas) {
        return (.5 + x*m10.val + y*m11.val) * canvas.getHeight();
    }

    eval {return this;}
}

fn cyclePositionPolicy {
    fout BrushPositionPolicy;
    in BrushPositionPolicy policy;
    eval {
        return new CycleBrushPositionPolicy(policy);
    }
}

fn simpleBrushSizePolicy {
    fout BrushSizePolicy;
    parameter LDouble xOffset;
    parameter LDouble yOffset;

    init {
        double xv = Math.random();
        double yv = Math.random();

        if(xv < .33333) {
            xOffset = new LDouble(0);
        } else if(xv < .66666) {
            xOffset = new LDouble(.5);
        } else {
            xOffset = new LDouble(1);
        }

        if(yv < .33333) {
            yOffset = new LDouble(0);
        } else if(yv < .66666) {
            yOffset = new LDouble(.5);
        } else {
            yOffset = new LDouble(1);
        }
    }

    eval {return new SimpleBrushSizePolicy(xOffset.val, yOffset.val);}
}