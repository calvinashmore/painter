/* Generated By:JJTree: Do not edit this line. ASTFnDefinition.java */
package fn;

import jd.*;
import java.util.*;

public class ASTFnDefinition extends FnParseNode implements Compileable {

    private String fnName;
    private ASTFnBlock eval;
    private ASTFnBlock estimate;
    private ASTFnBlock init;
    private ASTFnBlock setup;
    private ASTFnBlock necessaryContext;
    private ASTLocal local;
    private ASTMeta meta;
    //private ASTFnBlock parameters_in;
    //private ASTFnBlock parameters_out;
    private ASTOut output;
    private List<ASTIn> inputs = new LinkedList();
    private List<ASTOut> interfaces = new LinkedList();
    private List<ASTNBIn> nbInputs = new LinkedList();
    private List<ASTIn> parameters = new LinkedList();
    //private String paramsOutNumber;
    private Map<String, String> estimateMap = new Hashtable();

    public void setFnName(String fnName) {
        this.fnName = fnName;
    }

    public void setEval(ASTFnBlock eval) {
        this.eval = eval;
    }

    public void setEstimate(ASTFnBlock estimate) {
        this.estimate = estimate;
    }

    public void setInit(ASTFnBlock init) {
        this.init = init;
    }

    public void setLocal(ASTLocal local) {
        this.local = local;
    }

    public void setMeta(ASTMeta meta) {
        this.meta = meta;
    }

    public void setSetup(ASTFnBlock setup) {
        this.setup = setup;
    }

    public void setNecessaryContext(ASTFnBlock necessaryContext) {
        this.necessaryContext = necessaryContext;
    }
    //public void setParameters_in(ASTFnBlock parameters_in) {this.parameters_in = parameters_in;}
    //public void setParameters_out(ASTFnBlock parameters_out) {this.parameters_out = parameters_out;}
    //public void setParamsOutNumber(String paramsOutNumber) {this.paramsOutNumber = paramsOutNumber;}
    public void setOut(ASTOut out) {
        this.output = out;
    }

    public void addIn(ASTIn in) {
        this.inputs.add(in);
    }

    public void addInterface(ASTOut intf) {
        this.interfaces.add(intf);
    }

    public void addNBIn(ASTNBIn in) {
        this.nbInputs.add(in);
    }

    public void addParameter(ASTIn in) {
        this.parameters.add(in);
    }

    public boolean isNodeBase() {
        return !nbInputs.isEmpty();
    }

    public String getFnName() {
        return fnName;
    }

    public ASTFnDefinition(int id) {
        super(id);
        makeEstimateMap();
    }

    public ASTFnDefinition(FnParser p, int id) {
        super(p, id);
        makeEstimateMap();
    }

    public void makeEstimateMap() {
        estimateMap.put("LDouble", "Estimate_d");
        estimateMap.put("LVect2d", "Estimate_v2");
        estimateMap.put("LVect3d", "Estimate_v3");
        estimateMap.put("Quaternion", "Estimate_q");
        estimateMap.put("Complex", "Estimate_c");
        estimateMap.put("Color", "Estimate_col");
    // return of null, default to Estimate_param
    }

    public ASTFnBlock getEstimate() {
        return estimate;
    }

    public String mapEstimate(String normalType) {
        String r = estimateMap.get(normalType);
        if (r == null) {
            r = "Estimate_param";
        }
        return r;
    }

    public ClassDescriptor compileToJava() throws CompileException {

        ClassDescriptor thisClass = new ClassDescriptor();
        thisClass.addClassModifier("static");
        thisClass.className = fnName;
        if (nbInputs.isEmpty()) {
            thisClass.extendsClass = "ExpressionFunction";
        } else {
            return null;
        }
        /*else {
        thisClass.extendsClass = "NodeFunction_NodeBase";
        MethodDescriptor numberSubNodes = new MethodDescriptor();
        numberSubNodes.addModifier("public");
        numberSubNodes.addModifier("int");
        numberSubNodes.methodName = "getNumberSubnodes";
        numberSubNodes.addToBlockBody(new CodeStringDescriptor("return " + nbInputs.size() + ";"));
        thisClass.addMethod(numberSubNodes);
        MethodDescriptor getNodeBaseClass = new MethodDescriptor();
        getNodeBaseClass.addModifier("public");
        getNodeBaseClass.addModifier("Class");
        getNodeBaseClass.methodName = "getNodeBaseClass";
        getNodeBaseClass.addArgument("int", "i");
        for(int i=0;i<nbInputs.size();i++)
        getNodeBaseClass.addToBlockBody(new CodeStringDescriptor(
        "if(i == "+i+") return " + nbInputs.get(i).getType() + ".class;"
        ));
        getNodeBaseClass.addToBlockBody(new CodeStringDescriptor("return null;"));
        thisClass.addMethod(getNodeBaseClass);
        MethodDescriptor getNodeContextClass = new MethodDescriptor();
        getNodeContextClass.addModifier("public");
        getNodeContextClass.addModifier("Class");
        getNodeContextClass.methodName = "getNodeContextClass";
        getNodeContextClass.addArgument("int", "i");
        for(int i=0;i<nbInputs.size();i++)
        getNodeContextClass.addToBlockBody(new CodeStringDescriptor(
        "if(i == "+i+") return " + nbInputs.get(i).getContextType() + ".class;"
        ));
        getNodeContextClass.addToBlockBody(new CodeStringDescriptor("return null;"));
        thisClass.addMethod(getNodeContextClass);
        MethodDescriptor getNodeInputName = new MethodDescriptor();
        getNodeInputName.addModifier("public");
        getNodeInputName.addModifier("String");
        getNodeInputName.methodName = "getNodeInputName";
        getNodeInputName.addArgument("int", "i");
        for(int i=0;i<nbInputs.size();i++)
        getNodeInputName.addToBlockBody(new CodeStringDescriptor(
        "if(i == "+i+") return \"" + nbInputs.get(i).getName() + "\";"
        ));
        getNodeInputName.addToBlockBody(new CodeStringDescriptor("return null;"));
        thisClass.addMethod(getNodeInputName);
        }*/

        for (ASTOut intf : interfaces) {
            thisClass.addInterface(intf.getType());
        }

        // local
        if (local != null) {
            String localBlock = local.dumpBlock();
            localBlock = localBlock.replaceAll(">> >", ">>");
            thisClass.addToBlockBody(new CodeStringDescriptor(localBlock));
        }

        // parameter variable declarations
        for (ASTIn parameter : parameters) {
            FieldDescriptor parameterField = new FieldDescriptor();
            parameterField.fieldType = parameter.getType();
            parameterField.addFieldName(parameter.getName());
            parameterField.addFieldModifier("private");
            thisClass.addField(parameterField);
        }

        // init (constructor)
        if (init != null) {
            MethodDescriptor initMeth = new MethodDescriptor();
            initMeth.addModifier("public");
            initMeth.methodName = fnName;
            if (!nbInputs.isEmpty()) { // for nodebased, add nff constructor
                initMeth.addArgument("ExpressionFactory", "nff");
                initMeth.addToBlockBody(new CodeStringDescriptor("super(nff);"));
            }
            initMeth.addToBlockBody(new CodeStringDescriptor(init.dumpBlock()));
            if (meta != null) {
                for (int i = 0; i < meta.getNumber(); i++) {
                    initMeth.addToBlockBody(new CodeStringDescriptor("addMeta(\"" + meta.getName(i) + "\", " + meta.getValue(i) + ");"));
                }
            }
            thisClass.addMethod(initMeth);

            // override default constructor for compatability if init and nodebased
            if (!nbInputs.isEmpty()) {
                initMeth = new MethodDescriptor();
                initMeth.addModifier("public");
                initMeth.methodName = fnName;
                initMeth.addToBlockBody(new CodeStringDescriptor("this(null);"));
                thisClass.addMethod(initMeth);
            }

        } else if (!nbInputs.isEmpty()) {
            MethodDescriptor initMeth = new MethodDescriptor();
            initMeth.addModifier("public");
            initMeth.methodName = fnName;
            initMeth.addArgument("ExpressionFactory", "nff");
            initMeth.addToBlockBody(new CodeStringDescriptor("super(nff);"));
            thisClass.addMethod(initMeth);

            initMeth = new MethodDescriptor();
            initMeth.addModifier("public");
            initMeth.methodName = fnName;
            initMeth.addToBlockBody(new CodeStringDescriptor("this(null);"));
            thisClass.addMethod(initMeth);
        }

        // getReturnClass
        MethodDescriptor getReturnClassMeth = new MethodDescriptor();
        getReturnClassMeth.addModifier("public");
        getReturnClassMeth.addModifier("Class");
        getReturnClassMeth.methodName = "getReturnClass";
        getReturnClassMeth.addToBlockBody(new CodeStringDescriptor(
                "return " + output.getType() + ".class;"));
        thisClass.addMethod(getReturnClassMeth);

        // getInputClasses
        MethodDescriptor getInputClassesMeth = new MethodDescriptor();
        getInputClassesMeth.addModifier("public");
        getInputClassesMeth.addModifier("Class[]");
        getInputClassesMeth.methodName = "getInputClasses";
        if (inputs.isEmpty()) {
            getInputClassesMeth.addToBlockBody(new CodeStringDescriptor(
                    "return null;"));
        } else {
            String inputClasses = inputs.get(0).getType() + ".class";
            for (int i = 1; i < inputs.size(); i++) {
                inputClasses += ", " + inputs.get(i).getType() + ".class";
            }

            getInputClassesMeth.addToBlockBody(new CodeStringDescriptor(
                    "Class inputClasses[] = {" + inputClasses + "};"));
            getInputClassesMeth.addToBlockBody(new CodeStringDescriptor(
                    "return inputClasses;"));
        }
        thisClass.addMethod(getInputClassesMeth);

        MethodDescriptor getInputName = new MethodDescriptor();
        getInputName.addModifier("public");
        getInputName.addModifier("String");
        getInputName.methodName = "getInputName";
        getInputName.addArgument("int", "i");
        for (int i = 0; i < inputs.size(); i++) {
            getInputName.addToBlockBody(new CodeStringDescriptor(
                    "if(i == " + i + ") return \"" + inputs.get(i).getName() + "\";"));
        }
        getInputName.addToBlockBody(new CodeStringDescriptor("return null;"));
        thisClass.addMethod(getInputName);

        // evaluate
        MethodDescriptor evalMeth = new MethodDescriptor();
        evalMeth.addModifier("public");
        evalMeth.addModifier("Object"); // return type
        evalMeth.addArgument("Object", "inputs[]");
        evalMeth.addArgument("Context", "context");
        evalMeth.methodName = "evaluate";
        for (int i = 0; i < inputs.size(); i++) {
            ASTIn input = inputs.get(i);
            evalMeth.addToBlockBody(new CodeStringDescriptor(
                    input.getType() + " " + input.getName() + " = (" + input.getType() + ")inputs[" + i + "]; "));
        }

        String evalBlock = eval.dumpBlock();
        for (int i = 0; i < nbInputs.size(); i++) {
            ASTNBIn input = nbInputs.get(i);
            evalMeth.addToBlockBody(new CodeStringDescriptor(
                    "Node " + input.getName() + " = getNode(" + i + "); "));

            evalBlock = evalBlock.replaceAll(input.getName() + "Eval", "((" + input.getType() + ")" + input.getName() + ".evaluate())");
        }
        evalMeth.addToBlockBody(new CodeStringDescriptor(evalBlock));
        thisClass.addMethod(evalMeth);

        // estimate
        MethodDescriptor estimateMeth = new MethodDescriptor();
        estimateMeth.addModifier("public");
        estimateMeth.addModifier("Estimate"); // return type
        estimateMeth.addArgument("Estimate", "inputs[]");
        estimateMeth.methodName = "estimate";
        for (int i = 0; i < inputs.size(); i++) {
            ASTIn input = inputs.get(i);
            String type = mapEstimate(input.getType());
            estimateMeth.addToBlockBody(new CodeStringDescriptor(
                    type + " " + input.getName() + " = (" + type + ")inputs[" + i + "]; "));
        }
        for (int i = 0; i < nbInputs.size(); i++) {
            ASTNBIn input = nbInputs.get(i);
            String type = mapEstimate(input.getType());
            estimateMeth.addToBlockBody(new CodeStringDescriptor(
                    type + " " + input.getName() + " = (" + type + ")getEstimate(" + i + "); "));
        }
        if (estimate != null) {
            estimateMeth.addToBlockBody(new CodeStringDescriptor(estimate.dumpBlock()));
        } else {
            estimateMeth.addToBlockBody(new CodeStringDescriptor("return new " + mapEstimate(output.getType()) + "();"));
        }
        thisClass.addMethod(estimateMeth);

        if (setup != null) {
            MethodDescriptor setupMeth = new MethodDescriptor();
            setupMeth.addModifier("public");
            setupMeth.addModifier("void"); // return type
            setupMeth.methodName = "setup";

            /*
            for(int i=0;i<inputs.size();i++) {
            ASTIn input = inputs.get(i);
            setupMeth.addToBlockBody(new CodeStringDescriptor(
            input.getType() + " " + input.getName() + " = (" + input.getType() + ")inputs[" + i + "]; "
            ));
            }
            String setupBlock = setup.dumpBlock();
            for(int i=0;i<nbInputs.size();i++) {
            ASTNBIn input = nbInputs.get(i);
            setupMeth.addToBlockBody(new CodeStringDescriptor(
            "Node " + input.getName() + " = getNode(" + i + "); "
            ));
            setupBlock = setupBlock.replaceAll(input.getName() + "Eval", "((" + input.getType() + ")" + input.getName() + ".evaluate())");
            }*/

            String setupBlock = setup.dumpBlock();
            setupMeth.addToBlockBody(new CodeStringDescriptor(setupBlock));
            thisClass.addMethod(setupMeth);
        }

        if (necessaryContext != null) {
            MethodDescriptor necessaryContextMeth = new MethodDescriptor();
            necessaryContextMeth.addModifier("public");
            necessaryContextMeth.addModifier("String[]"); // return type
            necessaryContextMeth.methodName = "necessaryContext";
            necessaryContextMeth.addToBlockBody(
                    new CodeStringDescriptor("String s[] = {" + necessaryContext.dumpBlock() + "};"));
            necessaryContextMeth.addToBlockBody(new CodeStringDescriptor("return s;"));
            thisClass.addMethod(necessaryContextMeth);
        }

        // parameters
        if (parameters.size() > 0) {

            MethodDescriptor numberParameters = new MethodDescriptor();
            numberParameters.addModifier("public");
            numberParameters.addModifier("int");
            numberParameters.methodName = "getNumberParameters";
            numberParameters.addToBlockBody(new CodeStringDescriptor("return " + parameters.size() + ";"));
            thisClass.addMethod(numberParameters);

            MethodDescriptor getParameter = new MethodDescriptor();
            getParameter.addModifier("public");
            getParameter.addModifier("Object");
            getParameter.methodName = "getParameter";
            getParameter.addArgument("int", "i");
            for (int i = 0; i < parameters.size(); i++) {
                getParameter.addToBlockBody(new CodeStringDescriptor(
                        "if(i == " + i + ") return " + parameters.get(i).getName() + ";"));
            }
            getParameter.addToBlockBody(new CodeStringDescriptor("return null;"));
            thisClass.addMethod(getParameter);

            MethodDescriptor setParameter = new MethodDescriptor();
            setParameter.addModifier("public");
            setParameter.addModifier("void");
            setParameter.methodName = "setParameter";
            setParameter.addArgument("int", "i");
            setParameter.addArgument("Object", "param");
            for (int i = 0; i < parameters.size(); i++) {

                if (parameters.get(i).getType().equals("int")) {
                    setParameter.addToBlockBody(new CodeStringDescriptor(
                            "if(i == " + i + ") " + parameters.get(i).getName() + " = (Integer)param;"));
                } else if (parameters.get(i).getType().equals("double")) {
                    setParameter.addToBlockBody(new CodeStringDescriptor(
                            "if(i == " + i + ") " + parameters.get(i).getName() + " = (Double)param;"));
                } else {
                    setParameter.addToBlockBody(new CodeStringDescriptor(
                            "if(i == " + i + ") " + parameters.get(i).getName() + " = (" +
                            parameters.get(i).getType() + ")param;"));
                }
            }
            //setParameter.addToBlockBody(new CodeStringDescriptor("return null;"));
            thisClass.addMethod(setParameter);

            MethodDescriptor getParameterName = new MethodDescriptor();
            getParameterName.addModifier("public");
            getParameterName.addModifier("String");
            getParameterName.methodName = "getParameterName";
            getParameterName.addArgument("int", "i");
            for (int i = 0; i < parameters.size(); i++) {
                getParameterName.addToBlockBody(new CodeStringDescriptor(
                        "if(i == " + i + ") return \"" + parameters.get(i).getName() + "\";"));
            }
            getParameterName.addToBlockBody(new CodeStringDescriptor("return null;"));
            thisClass.addMethod(getParameterName);

            MethodDescriptor getParameterType = new MethodDescriptor();
            getParameterType.addModifier("public");
            getParameterType.addModifier("Class");
            getParameterType.methodName = "getParameterType";
            getParameterType.addArgument("int", "i");
            for (int i = 0; i < parameters.size(); i++) {
                getParameterType.addToBlockBody(new CodeStringDescriptor(
                        "if(i == " + i + ") return " + parameters.get(i).getType() + ".class;"));
            }
            getParameterType.addToBlockBody(new CodeStringDescriptor("return null;"));
            thisClass.addMethod(getParameterType);
        }


        /*
        // parameters out
        if(parameters_out != null) {
        MethodDescriptor paramsOutMeth = new MethodDescriptor();
        paramsOutMeth.addModifier("public");
        paramsOutMeth.addModifier("Object[]"); // return type
        paramsOutMeth.methodName = "getParameters";
        paramsOutMeth.addToBlockBody(new CodeStringDescriptor("Object r[] = new Object[" + paramsOutNumber + "];"));
        paramsOutMeth.addToBlockBody(new CodeStringDescriptor(parameters_out.dumpBlock()));
        paramsOutMeth.addToBlockBody(new CodeStringDescriptor("return r;"));
        thisClass.addMethod(paramsOutMeth);
        }
        // parameters in
        if(parameters_in != null) {
        MethodDescriptor paramsInMeth = new MethodDescriptor();
        paramsInMeth.addModifier("public");
        paramsInMeth.addModifier("void"); // return type
        paramsInMeth.addArgument("Object[]", "params");
        paramsInMeth.methodName = "setParameters";
        paramsInMeth.addToBlockBody(new CodeStringDescriptor(parameters_in.dumpBlock()));
        thisClass.addMethod(paramsInMeth);
        }*/

        return thisClass;
    }
}
